// ---------------- [ File: hydro2-network/tests/trybuild/pass_hybrid_01.rs ]
// tests/trybuild/pass_hybrid_01.rs

use std::marker::PhantomData;

use hydro2_network_wire_derive::*;
use hydro2_operator_derive::*;
use hydro2_basic_operators::*;
use hydro2_network::*;
use hydro2_operator::*;
use hydro2_3p::*;

// 1) Define two trivial operators that produce separate *IO types via #[derive(Operator)].

#[derive(Debug, NamedItem, Operator)]
#[operator(
    execute="execute_inc",
    opcode="OpCode::IncrementOperator",
    input0="i32",
    output0="i32"
)]
pub struct IncOperator {
    name: String,
}

impl IncOperator {
    pub async fn execute_inc(&self, input0: &i32) -> NetResult<i32> {
        Ok(input0 + 1)
    }
}

#[derive(Debug, NamedItem, Operator)]
#[operator(
    execute="execute_double",
    opcode="OpCode::DoubleOp",
    input0="i32",
    output0="i32"
)]
pub struct DoubleOperator {
    name: String,
}

impl DoubleOperator {
    pub async fn execute_double(&self, input0: &i32) -> NetResult<i32> {
        Ok(input0 * 2)
    }
}

// 2) Now define our "wire type" that can hold these two operator IOs in one big enum:
#[derive(NetworkWire)]
#[available_operators(
    op="IncOperator",  // => IncOperatorIO
    op="DoubleOperator",
    op="ConstantOp<T>",
)]
pub struct MyNetworkWireA<T> 
where T: Display + Copy + Debug + Send + Sync + PartialEq,
{
    // If you had generics, you'd do: <T, X> { ...PhantomData... } 
    _p: PhantomData<T>,
}

// 3) Build a small network using these operators and see if it compiles & runs:

fn main() {

    // Build the network with your `network!` macro
    let mut net: Network<MyNetworkWireAIO<i32>> = network!(
        // The "wire type" => MyNetworkWireAIO (auto-generated by the macro).
        // We'll build a two-node network: Node0=IncOperator, Node1=DoubleOperator => chain them.
        vec![
            node!(0 => IncOperator { name: "inc operator".to_string() }),
            node!(1 => DoubleOperator { name: "double operator".to_string() }),
            node!(2 => ConstantOp::<i32>::new(0)),
        ],
        // single edge => node0:0 -> node1:0
        vec![
            edge!(0:0 -> 1:0),
            edge!(2:0 -> 0:0),
        ]
    );

    // Now let's do a quick check that we can set the input for node0,
    // run node0 => (inc) => run node1 => (double)
    // For demonstration, let's do a small "manually poke inputs" approach:
    //  - Usually you'd do something like wire an external input into node0's input0. 
    //    We'll just do a manual assignment in code.

    // Node0 => input_count=1 => let's store a 10 in the input
    if let Some(arc_slot) = net.nodes_mut()[0].inputs_mut()[0].as_mut() {
        // Overwrite the slot with 10
        use tokio::runtime::Runtime;
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let mut lock = arc_slot.write().await;
            *lock = MyNetworkWireAIO::ConstantOpIO(ConstantOpIO::Output0(10i32)); // store 10
        });
    }

    // Now run node0, node1 in order. Typically you'd do a topological sequence or a scheduler:
    {
        use tokio::runtime::Runtime;
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            // node0 => inc
            net.nodes()[0].execute().await.unwrap();
            // node1 => double
            net.nodes()[1].execute().await.unwrap();
        });
    }

    // The final output => node1.outputs()[0] should be (10+1)*2 = 22
    if let Some(arc_slot) = net.nodes()[1].outputs()[0].as_ref() {
        use tokio::runtime::Runtime;
        let rt = Runtime::new().unwrap();
        let val = rt.block_on(async {
            arc_slot.read().await.clone()
        });
        let val = val.port_try_into_dynamic::<i32>().unwrap();
        assert_eq!(val, 22);
        println!("Success: final output={}", val);
    }
}
